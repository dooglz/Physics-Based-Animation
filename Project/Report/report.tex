%%% This LaTeX source document can be used as the basis for your technical
%%% report. Intentionally stripped and simplified
%%% and commands should be adjusted for your particular paper - title, 
%%% author, citations, equations, etc.
% % Citations/references are in report.bib 

\documentclass[conference]{acmsiggraph}

\usepackage{graphicx}
\graphicspath{{./images/}}
\newcommand{\figuremacroW}[4]{
	\begin{figure}[h] %[htbp]
		\centering
		\includegraphics[width=#4\columnwidth]{#1}
		\caption[#2]{\textbf{#2} - #3}
		\label{fig:#1}
	\end{figure}
}

\newcommand{\figuremacroF}[4]{
	\begin{figure*}[h] % [htbp]
		\centering
		\includegraphics[width=#4\textwidth]{#1}
		\caption[#2]{\textbf{#2} - #3}
		\label{fig:#1}
	\end{figure*}
}


\usepackage{lipsum}

\TOGonlineid{45678}
\TOGvolume{0}
\TOGnumber{0}
\TOGarticleDOI{1111111.2222222}
\TOGprojectURL{}
\TOGvideoURL{}
\TOGdataURL{}
\TOGcodeURL{}

\title{Performance Analysis of Real Time Multi-platform Physics Simulations \\
	   Final Report}

\author{Sam Serrels\\\ 40082367@napier.ac.uk \\
Edinburgh Napier University\\
Physics-Based Animation (SET09119)}
\pdfauthor{Sam Serrels}

\keywords{Multi-platform Physics, Optimisation, GPU, Cell, PS3}

\begin{document}

\teaser{
   \includegraphics[height=1.5in]{images/sampleteaser}
   \caption{Project screenshot}   
 }		

\maketitle

\begin{abstract}
This project aimed to develop a physics engine and simulate a scene consisting of thousands of bouncing balls, running on various systems, such as the Sony Playstion 3.
The performance of each system was measured as the systems were optimised and are compared in this final report.
\end{abstract}

\keywordlist
%\copyrightspace

\section{Introduction}

\paragraph{Project Aims}
This project attempted to create a physics solution that would run on various systems, along with a game engine with an appropriate interface to swap in other existing physics solutions. 
The target platforms were the Sony Playstation 3, and a conventional x86 multi-core PC architecture.

\paragraph{Simulation}
The scene that is simulated is a large set of Bouncing balls, a scenario picked for it's large potential for parallelisation and general visual appeal. The inspiration for this came from a television advert where thousands of bouncing balls were thrown down a sloped street.

\section{Background / Related Work}
Real-time physics on a Playstation 3 is exclusively used in video games, where speed and resource optimisations take priority over simulation accuracy. Often the physics solutions are tailor made for each visual effect, full general physics solvers are rare. Only games which rely on physics as a gameplay element devote much processor time to physics.
PC exclusive titles tend to take a more relaxed approach to physics, due to the extra resources available. Games may use a full physics sovler just for aesthetic value with no additional gameplay mechanics. This can also be a causation of a multitude of physics libraries available for the PC platform.


\section{Software Design}
Methodology/Software design/logic control. You are expected to do some software
modelling of your physics-based animation choice. At a minimum you are expected to
provide some state modelling and sequence modelling. Avoid providing simple models just
to fill in this section, and only highlight some of the core functionality.

The solution is split into three projects: Physics, Engine, and Game.
\paragraph{Game}
The Game project is the highest level, it has no need to understand how the Engine works, or what platform the code is running on. This is where the simulation scene is created, with all the balls initialised. This project also hosts the Main function, the program entry point; where the main game loop is created an run.

\paragraph{Engine}
The code within the Engine project is responsible for managing all the internal systems and platform specific code. The structure is designed to maximize code reuse across the platform code, while minimizing the need for including preprocessor checks. Interface classes are used extensively to abstract the platform code as much as possible from each subsystem, this does result in a large amount of extra classes, but the benefit of code clarity in each class outweighs the negative cost of more files for this size of project.

\paragraph{Physics}
This is where all the physics code is written and executed. The Library supports Plane, Sphere and cuboid shapes for rigid body simulation. These shape objects are created by the Engine and synced with the enties object used for rendering every frame. The physics library keeps track of every object created in a collection called a scene.

The Engine and Physics Projects are compiled as a library, and linked with the Game project.

\paragraph{Engine Entity component Model}
The Engine stores render objects as Entities, each of which has a set of components attached to it.
The components used in this project are a Mesh renderer component, a camera component, a keyboard movement component and the three set of physics shapes as components. The base entity class only stores  position, rotation and housekeeping data.
This follows the entity component model, which allows for complex combinations of entities, without the need for complex inheritance trees.

\paragraph{Engine Modularity}
Each system of the engine has been designed with as little dependency on each other as possible. This is enforced strongly for the low level rendering classes, as these have the least amount of shared code across platforms. The interface between the Engine and the Physics project is set-up so another physics library could be used with only a small wrapper class needed for each new library.

\figuremacroW
{physicsclasses}
{Physics Dependency Graph}
{Forward decelerations are used to minimize header co-dependency throughout the project}
{1.0}

\paragraph{Design of Physics Library}
The Physics library is rather small compared to the Engine library, it makes use of the same maths library and utility classes, allowing for easy transfer of data between the systems. The physics system has a single "Scene" which hosts all the "Physics Objects" which take the form of the different rigid body shapes.

\paragraph{Physics Process}
There are multiple physics updates or "Ticks" every frame. The time the simulation uses as the the time between ticks is constant, in this project the tickrate	is set to a 100th of a second. The amount of ticks per frame depends on how much real time has passed between frames and the tickrate.\\	
At the start of each tick, the first process is collision detection. This checks every object against evy other object. Spacial partitioning is used to narrow this search space down to only check for collisions against objects that are near each other.
	
\section{Results}
Experimental Results/description of your physics-based simulation implementation
including screenshots.

\section{Evaluation}
Evaluation - An evaluation of your implementation. Points to consider discussing in this
section are:
 A comparison against the original concept
 Comparison against other simulations in the genre, particularly the ones that
inspired your choice
 A discussion on the quality of the simulation
 Possible improvements to your simulation

\section{Future Work}


\figuremacroW
{balls2}
{Project Inspiration}
{\protect\cite{advert}}
{0.96}



\bibliographystyle{acmsiggraph}
\bibliography{report}

\end{document}

